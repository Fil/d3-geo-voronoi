<!DOCTYPE html>
<html>

<head>
    <title>BenchMark: Sphere</title>
</head>

<body>

    <meta charset="utf-8">
    <style>
        #sphere {
            stroke: #444;
            stroke-width: 2;
        }

        .polygons {
            stroke: #444;
        }

        .sites {
            stroke: black;
            fill: white;
        }

        .range-wrapper {
            display: grid;
            grid-template-columns: 10% 80% 10%;
        }
    </style>

    <h1>d3-geo-voronoi Benchmark: Sphere</h1>
    <p> This benchmark renders to a SVG element.</p>
    <p class="range-wrapper">
        <span style="text-align:right">5</span>
        <input id="size-range" width="80%" type="range" min="5" max="1000" step="5" onchange=gen_points()>
        <span>1000</span>
    </p>
    <div style="font-weight: bold;">
        <label id="size-label" for="size-range">The number of points on the sphere</label>
        <p id="perf">Mean Render Time: ...Calculating</p>
    </div>
    <p> The mean render time and standard deviation are based on the last 200 frames. </p>
    <svg width="960" height="600"></svg>

    <script src="https://unpkg.com/d3@6"></script>
    <script src="../dist/d3-geo-voronoi.js"></script>

    <script>
        const size_range = document.getElementById("size-range");
        const size_label = document.getElementById("size-label");
        const perf = document.getElementById("perf");
        const svg = d3.select("svg");
        const projection = d3.geoOrthographic();
        const path = d3.geoPath().projection(projection);

        let points;
        let v;
        // Holds elapsed samples (use to compute the standard deviation).
        let elapsedArray;
        // index into the elapsedArray 0..199
        let index;

        const gen_points = () => {
            const n_points = size_range.value;
            size_label.innerText = `The number of points on the sphere: ${n_points}`;
            index = 0;
            elapsedArray = [];
            perf.innerHTML = "Render Time: ...Calculating"
            points = {
                type: "FeatureCollection",
                features: d3.range(n_points).map(() => {
                    return {
                        type: "Point",
                        coordinates: [360 * Math.random(), 180 * Math.random() - 90]
                    }
                })
            };
            v = d3.geoVoronoi()(points);

            svg.append('path')
                .attr('id', 'sphere')
                .datum({ type: "Sphere" })
                .attr('d', path);
            svg.append('g')
                .attr('class', 'polygons')
                .selectAll('path')
                .data(v.polygons().features)
                .enter()
                .append('path')
                .attr('d', path)
                .attr('fill', function (_, i) { return d3.schemeCategory10[i % 10]; });
            svg.append('g')
                .attr('class', 'sites')
                .selectAll('path')
                .data(points.features)
                .enter()
                .append('path')
                .attr('d', path);
        };
        gen_points();

        const render = (elapsed) => {
            const t0 = performance.now();
            projection.rotate([elapsed / 150, 0]);
            svg.selectAll('path')
                .attr('d', path);
            const t1 = performance.now();
            
            // Compute the mean elapsed time and compute the standard deviation based on the
            // the last 200 samples.
            elapsed = (t1 - t0);
            index = (index + 1) % 200;
            elapsedArray[index] = elapsed;
            if (index == 199) {
                const n = elapsedArray.length;
                const mean = elapsedArray.reduce((a, b) => a + b, 0) / n;
                const stdDev = Math.sqrt(elapsedArray.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
                const meanString = mean.toPrecision(4);
                const stdDevString = stdDev.toPrecision(4);
                perf.innerHTML = `Mean Render Time: ${meanString} +/- ${stdDevString} ms`;
            }
            window.requestAnimationFrame(render);
        }

        window.requestAnimationFrame(render);
    </script>
</body>

</html>